# 企业面试题

##1. 阅读下面的代码，写出A0，A1至An的最终值。
```python

\1.    A0 = dict(zip(('a'，'b'，'c'，'d'，'e')，(1，2，3，4，5)))

\2.    A1 = range(10)

\3.    A2 = [i for i in A1 if i in A0]

\4.    A3 = [A0[s] for s in A0]

\5.    A4 = [i for i in A1 if i in A3]

\6.    A5 = {i:i*i for i in A1}

\7.    A6 = [[i，i*i] for i in A1]

答：

\1.   A0 = {'a': 1， 'c': 3， 'b': 2， 'e': 5， 'd': 4}

\2.   A1 = [0， 1， 2， 3， 4， 5， 6， 7， 8， 9]

\3.   A2 = []

\4.   A3 = [1， 3， 2， 5， 4]

\1.   A4 = [1， 2， 3， 4， 5]

\2.   A5 = {0: 0， 1: 1， 2: 4， 3: 9， 4: 16， 5: 25， 6: 36， 7: 49， 8: 64， 9: 81}

\3.   A6 = [[0， 0]， [1， 1]， [2， 4]， [3， 9]， [4， 16]， [5， 25]， [6， 36]，[7， 49]，[8， 64] [9，81]]
```

##2.  range和xrange的区别？

两者用法相同，不同的是range返回的结果是一个列表，而xrange的结果是一个生成器，前者是直接开辟一块内存空间来保存列表，后者是边循环边使用，只有使用时才会开辟内存空间，所以当列表很长时，使用xrange性能要比range好。

## 3. 考虑以下Python代码，如果运行结束，命令行中的运行结果是什么？

```python

\1.  l = []

\2.   for  i  in  xrange(10):

\3.       l.append({‘num’:i})

\4.   print l
```
载考虑以下代码，运行结束后的结果是什么？

```python
\1.   l = []

\2.   a = {‘num’:0}

\3.   for i in xrange(10):

\4.       a[‘num’] = i

\5.       l.append(a)

\6.   print l
```
以上两段代码的运行结果是否相同，如果不相同，原因是什么？

上方代码的结果：
```python
\1.  [{‘num’:0}，{‘num’:1}，{‘num’:2}，{‘num’:3}，{‘num’:4}，{‘num’:5}，{‘num’:6}，{‘num’:7}，{‘num’:8}，{‘num’:9}]
```
下方代码结果：
```python
\1.  [{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}，{‘num’:9}]
```
原因是：字典是可变对象，在下方的 l.append(a)的操作中是把字典 a的引用传到列表 l 中，当后续操作修改a[‘num’]的值的时候，l 中的值也会跟着改变，相当于浅拷贝。

##4. 以下Python程序的输出？

```python
\1. for i in range(5，0，-1):

\2.       print(i)

```

​	答：5 4 3 2 1