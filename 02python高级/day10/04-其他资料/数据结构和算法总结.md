# 数据结构和算法

数据结构:存储和组织数据的方式

算法:解决问题的思路(不依赖代码)

# 算法的效率衡量标准

事后统计法

缺点:不同的硬件执行时间不一样  数据规模比较小,不能够反映算法的效率  100n  n^2

**时间复杂度**

算法执行时间随着数据规模的变化的增长趋势,渐进时间复杂度

O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)

logn:二分查找

nlogn:快速排序  logn轮数  n:每一轮移动指针的次数

**最好最坏时间复杂度**

最好:O(n)

最坏:O(n^2)

**空间复杂度**

算法的内存随着数据规模的变化的增长趋势,渐进空间复杂度

O(1)

O(n)

# 数据结构

**逻辑分类**

线性结构:每个节点最多只有一个前驱节点和后继节点

顺序表  链表 栈 队列

非线性结构:每个节点有多个前驱节点和后继节点

树  图

**顺序表**

一体式:信息区和数据区在一起

分离式:信息区和数据区不在一起

元素外置:数据区存储的是数据的地址

优点:查询快

缺点:连续内存空间  添加和删除时间复杂度高

**链表**

不需要连续的控件,每一个元素都是一个节点 存数据域和指针域

优点:不需要连续的内存 数据量大 删除和添加操作比较快

缺点:查询慢

# 栈和队列

**栈**

先进后出

顺序表:后面添加和删除O(1)

链表:头部添加和删除O(1)

**队列**

先进先出

顺序表:一端进一端出O(n)

链表:需要添加头部和尾部指针  尾部添加数据  头部删除数据

# 排序算法

## 冒泡排序

两两比较

最好:O(n)

最坏O(n^2)

原地排序:是

稳定排序:稳定

## 选择排序

**时间复杂度**

O(n^2)

原地排序:是

稳定:不稳定2355

## 插入排序

**时间复杂度**

最好:O(n)

最坏:O(n^2)

原地排序:是

稳定:是

## 快速排序

不断找一个数据 把小于这个数据放到左边,大于的放在右边

**时间复杂度**

最坏:O(n^2)   123456789 

最好:O(nlogn)

原地排序:是

稳定排序:不稳定

# 二分查找

**前提**

顺序表,有序数据 一次排序,多次查找

**时间复杂度**

最好:O(1)

最坏:logn n

空间复杂度:递归O(n^2)(目前) 非递归O(1)

# 树

**什么是树?**

①每个节点有零个或多个子节点
②没有父节点的节点称为根节点
③**每一个非根节点有且只有一个父节点**
④除了根节点外，每个子节点可以分为多个不相交的子树

**概念**

节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推
树的高度或深度：树中节点的最大层次

# 二叉树

每一个节点最多只有两个子节点

1. 完全二叉树  

   对于一颗二叉树，假设其深度为d(d>1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树

2. 满二叉树  每一层都满节点

3. 平衡二叉树  当且仅当任何节点的两棵子树的高度差不大于1的二叉树

4. 二叉搜索树  节点左边都比当前节点小  右边都比当前节点大  子树也满足这个条件

**二叉树的性质**

对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子
编号必为2i＋1 , 其父节点的编号必为i//2（i＝1 时为根,除外）

## 完全二叉树的实现

1. 顺序表 可以存储完全二叉树
2. 链表  数据  左节点  右节点

**添加数据**

**广度优先遍历**

一层一层遍历

**深度优先遍历**

先序遍历

中序遍历

后序遍历

**遍历结果倒推树结构**

