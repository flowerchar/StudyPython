1. 思考下面的代码运行出的结果是什么:
    list = [0, 1, 2]
    list[1] = list
    print(list)
	
	
参考答案:
	[0, [...], 2]
    list的第2个元素指向list本身, 所以无限循环
    
2. 如何得出list = [0, [0, 1, 2], 2]这样的结果?

参考答案:
    list[1] = list[:] 
	列表的切片其实是浅拷贝
	


3. 经过以下步骤, a和b分别是多少? 为什么? 
    a = [0, [1, 2], 3]
    
    b = a[:]
    a[0] = 8
    a[1][1] = 9
    
参考答案:

a = [8, [1, 9], 3]
b = [0, [1, 9], 3]

a[:]是浅拷贝, 只对对象最顶层进行拷贝
    
4. 如何保证第3题中最终b = [0, [1, 2], 3]

参考答案: 使用深拷贝


5. 写出下面代码执行结果:
    L = [1, 2]
    M = L
    L = L + [3, 4]
    print(L)
    print(M)
    
    
6. 写出下面代码执行结果:
    L = [1, 2]
    M = L
    L += [3, 4]
    print(L)
    print(M)
    
   L += [3, 4]  是L本身加上[3, 4]
   
   L = L + [3, 4] 先计算等号右边, 得到一个新的引用, 指向新的L(等号右边的L是原来的L, 等号左边的是一个新的L)

    
7. 执行以下代码:

def foo(a, b, c=[]):
    c.append(a)
    c.append(b)
    print(c)

foo(1, 2)   python解释器没有接收到c的参数, 使用默认的空列表(缺省参数)

foo(1, 2, [])   python解释器接收到新的c的参数, 就是用新的空列表, 此时, 缺省参数的列表已经变为[1, 2]

foo(3, 4)   python解释器没有接收到c的参数, 继续使用默认的缺省列表, 即[1, 2].append[3, 4]




